<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FTT Big List</title>

  <!-- Performance hints -->
  <link rel="preconnect" href="https://unavatar.io" crossorigin>
  <link rel="preconnect" href="https://www.google.com" crossorigin>
  <link rel="preconnect" href="https://images.weserv.nl" crossorigin>
  <link rel="dns-prefetch" href="//unavatar.io">
  <link rel="dns-prefetch" href="//images.weserv.nl">
  <link rel="dns-prefetch" href="//www.google.com">

  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: #f4f7fa; color: #222;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: flex; flex-direction: column;
    }

    header { display: grid; gap: 6px; padding: 6px 10px; background: #0078d7; color: #fff; box-shadow: 0 1px 2px rgba(0,0,0,.10); }
    header .top { display:flex; gap:12px; align-items:center; }
    h1 { margin:0; font-size:14px; font-weight:750; line-height:1.1; }
    .meta { margin-left:auto; font-size:12px; opacity:.95; }
    .meta.error { color: #ffe9e9; }

    .button-row { display:flex; flex-wrap:wrap; gap:6px; }
    .btn { color:#fff; background:#0063b1; border:0; border-radius:8px; padding:.35rem .6rem; font-weight:700; font-size:13px; cursor:pointer; }
    .btn.us{background:#0078d7}.btn.canada{background:#d83b01}.btn.samerica{background:#107c10}
    .btn.europe{background:#6b46c1}.btn.eastasia{background:#e81123}.btn.mideast{background:#ffb900;color:#333}
    .btn.active{outline:2px solid #fff; outline-offset:1px; filter:brightness(1.05)}

    .controls {
      display:flex; flex-wrap:wrap; gap:10px; align-items:center; font-size:12px; justify-content:flex-start;
    }
    .controls .switch { display:flex; align-items:center; gap:6px; background:#ffffff22; padding:3px 8px; border-radius:8px; }
    .controls input[type="search"]{
      padding:6px 8px; border-radius:8px; border:1px solid #c8d7eb; min-width:240px;
      outline: none;
    }
    .controls select, .controls button {
      font-size:12px; padding:3px 8px; border-radius:6px; border:none;
    }
    .controls .btn-plain { background:#ffffff22; color:#fff; }

    main { display:flex; flex-direction:column; }
    .table-wrap { height: calc(100vh - 142px); overflow:auto; background:#fff; border-top:1px solid #e9eef4; border-bottom:1px solid #e9eef4; }

    /* Table */
    table { border-collapse: separate; border-spacing: 0; width: 100%; table-layout: fixed; font-size: 14px; min-width: 2200px; }
    tbody td {
      border-bottom:1px solid #f0f3f6; padding:8px 10px; vertical-align: top;
      white-space: normal; overflow-wrap: break-word; word-break: normal; hyphens: manual; line-height:1.35;
      background: #fff;
    }
    tbody tr:nth-child(2n){ background:#fafcff; }

    /* Row 1 hidden; Row 2 sticky */
    tbody tr.is-hidden { display: none; }
    tbody tr.sticky-second td {
      position: sticky; top: 0; z-index: 4;
      background: linear-gradient(#f7fafc, #eef3f9);
      border-bottom: 2px solid #e0e6ee;
    }

    /* State header row */
    tr.state-header > td {
      background: #000 !important; color:#fff !important;
      font-weight: 700; letter-spacing: .2px;
      border-bottom: 2px solid #111;
      position: sticky; top: 40px; z-index: 3;
    }
    tr.state-header .state-bar { display:flex; align-items:center; gap:10px; cursor: pointer; }
    .chev {
      width: 0; height: 0;
      border-left: 6px solid currentColor;
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
      transition: transform .15s ease;
    }
    .expanded .chev { transform: rotate(90deg); }
    tr[data-collapsed="true"] { display: none; }

    /* Image column + hiding */
    .imgCol { width: 160px; }
    .thumb  { width: 120px; height: 120px; border-radius:10px; border:1px solid #ececec; object-fit:cover; display:block; background:#f1f1f1; }
    .skeleton { width: 120px; height: 120px; background:#e6e6e6; border-radius:10px; border:1px solid #ececec; }
    .hide-images col:first-child { width:0 !important; }
    .hide-images .imgCol { display:none; }

    /* Links */
    td a { white-space: nowrap; display:inline-block; max-width:100%; overflow:hidden; text-overflow:ellipsis; }
    .cell-link { color: inherit; text-decoration: underline; }
    .full-url {
      display:none; margin-top:6px; font-size:12px; color:#333;
      word-break: break-all; white-space: normal;
      background:#f6f8fb; border:1px solid #e5ebf3; border-radius:6px; padding:6px;
    }
    .show-full .full-url { display:block; }

    /* Global text clamp + More/Less */
    .clamp-wrap { display:-webkit-box; -webkit-box-orient:vertical; overflow:hidden; }
    .clamp-3 { -webkit-line-clamp:3; }
    .moreless { display:inline-block; margin-top:6px; font-size:12px; color:#0063b1; cursor:pointer; user-select:none; }

    /* Search hide */
    .search-row-hide { display: none !important; }

    /* Tiny icon cells (Column I) */
    .sentiment { font-size:18px; line-height:1; }

    /* Debug helper (optional) */
    .debug { font-size:11px; opacity:.85; }
  </style>
</head>
<body>
  <header>
    <div class="top">
      <h1>FTT Big List</h1>
      <div class="meta" id="meta">loading…</div>
    </div>

    <div class="button-row" role="navigation" aria-label="Tabs">
      <button class="btn us active"      data-gid="0">United States</button>
      <button class="btn canada"         data-gid="918890863">Canada</button>
      <button class="btn samerica"       data-gid="506975496">South America + Caribbean</button>
      <button class="btn europe"         data-gid="1560092023">Europe + Nordic</button>
      <button class="btn eastasia"       data-gid="1966795654">East Asia + Oceania + Australia</button>
      <button class="btn mideast"        data-gid="1604960979">Middle East</button>
    </div>

    <div class="controls">
      <input id="searchBox" type="search" placeholder="Search…" />
      <button id="clearSearch" class="btn" style="background:#666">Clear</button>

      <label class="switch" title="Toggle row thumbnails">
        <input id="imgToggle" type="checkbox" />
        Show images
      </label>

      <button id="expandAll" class="btn" style="background:#3aa655">Expand all</button>
      <button id="collapseAll" class="btn" style="background:#b83d3d">Collapse all</button>

      <span style="margin-left:8px">Sort within state by</span>
      <select id="sortCol" aria-label="Sort column">
        <option value="">— None —</option>
        <option value="A">Location</option>
        <option value="C">Domme</option>
        <option value="H">Verified?</option>
        <option value="I">Experience?</option>
        <option value="J">Price range?</option>
      </select>
      <select id="sortDir" aria-label="Sort direction">
        <option value="asc">Asc</option>
        <option value="desc">Desc</option>
      </select>
      <button id="applySort" class="btn-plain">Apply</button>
      <button id="clearSort" class="btn-plain">Clear</button>

      <button id="exportCsv" class="btn" style="background:#0a7ea4">Export CSV (current view)</button>
      <button id="exportAllCsv" class="btn" style="background:#0a5a7a">Export CSV (all tabs)</button>
    </div>

    <div id="dbg" class="debug" aria-live="polite"></div>
  </header>

  <main>
    <div class="table-wrap" id="scrollWrap">
      <table id="tbl" aria-live="polite">
        <colgroup id="colg"></colgroup>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </main>

  <script>
  /** ==== CONFIG ==== */
  const FILE_ID = "1hse75kxI9Gcb7g_tc9LOZ5dYVkFgDcNCrLKyq03cnHg";
  let   GID     = "0";
  const RANGE   = "A1:AA50000";
  const MAX_SHOW_COL_LETTER = "S";
  const MAX_SHOW_COL_IDX = colLetterToIdx(MAX_SHOW_COL_LETTER);

  /* Tabs for all-tabs export */
  const TABS = [
    { name: "United States", gid: "0" },
    { name: "Canada", gid: "918890863" },
    { name: "South America + Caribbean", gid: "506975496" },
    { name: "Europe + Nordic", gid: "1560092023" },
    { name: "East Asia + Oceania + Australia", gid: "1966795654" },
    { name: "Middle East", gid: "1604960979" },
  ];

  /* Remember-last-tab + per-tab scroll keys */
  const ACTIVE_GID_KEY = "ftt-active-gid";
  const SCROLL_KEY_PREFIX = "ftt-scroll:"; // + GID

  /* Wider columns */
  const WIDE_COLS = ["K","R"];
  const WIDE_IDX  = WIDE_COLS.map(colLetterToIdx);

  /* Image pref column (V) */
  const IMAGE_PREF_COL_LETTER = "V";
  const IMAGE_PREF_COL_IDX = colLetterToIdx(IMAGE_PREF_COL_LETTER);

  /* Column indexes (A=0): E=4, F=5, G=6, H=7, I=8, J=9, P=15, Q=16 */
  const E_COL_IDX = 4, F_COL_IDX = 5, G_COL_IDX = 6, H_COL_IDX = 7, I_COL_IDX = 8, J_COL_IDX = 9, P_COL_IDX = 15, Q_COL_IDX = 16;

  let POLL_MS = 120000;
  let ROW_CAP = 2000;
  const THUMB_PX = 120;

  const MAX_CONCURRENT_IMG = 8;
  const IMG_TIMEOUT_MS = 3000;
  const LAZY_ROOT_MARGIN = '1200px 0px';

  /* Column headers A..S */
  const COL_HEADERS = [
    "Location","Alternative Location","Domme","Images/Aliases","Website","Link tree/All links",
    "X/BlueSky","Verified?","Experience?","Price range?","Review/notes","Renown",
    "Link to full review","Travels?","email","Reddit","phone","Services Provided","link"
  ];

  /** ==== DOM ==== */
  const $  = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));
  const tbody = $("#tbody");
  const colg  = $("#colg");
  const meta  = $("#meta");
  const dbg   = $("#dbg");
  const imgToggle = $("#imgToggle");
  const expandAllBtn = $("#expandAll");
  const collapseAllBtn = $("#collapseAll");
  const sortColSel = $("#sortCol");
  const sortDirSel = $("#sortDir");
  const applySortBtn = $("#applySort");
  const clearSortBtn = $("#clearSort");
  const searchBox = $("#searchBox");
  const clearSearchBtn = $("#clearSearch");
  const exportBtn = $("#exportCsv");
  const exportAllBtn = $("#exportAllCsv");
  const scrollWrap = $("#scrollWrap");

  /** ==== State ==== */
  let currentRows = [];
  let currentColCount = 0;
  let sortSpec = null;
  let lastQuery = "";
  let imgCandCache = new Map();

  /** ==== Concurrency limiter for images ==== */
  let inflight = 0;
  const pendingStarts = [];
  function schedule(startFn){
    if (inflight < MAX_CONCURRENT_IMG){
      inflight++;
      startFn();
    } else {
      pendingStarts.push(startFn);
    }
  }
  function doneOne(){
    inflight = Math.max(0, inflight - 1);
    if (pendingStarts.length){
      const fn = pendingStarts.shift();
      inflight++;
      fn();
    }
  }

  /** ==== Lazy image observer ==== */
  const lazyImgObserver = new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{
      if (!entry.isIntersecting) return;
      const starter = entry.target._startLoading;
      if (starter) schedule(starter);
      lazyImgObserver.unobserve(entry.target);
    });
  }, { root: scrollWrap, rootMargin: LAZY_ROOT_MARGIN, threshold: 0.01 });

  /** ==== Utilities ==== */
  function colLetterToIdx(letter){ let n=0; for(let i=0;i<letter.length;i++) n=n*26+(letter.charCodeAt(i)-64); return n-1; }
  const URL_RE = /(https?:\/\/[^\s)'"<>]+)/i;
  const IMG_EXT_RE   = /\.(png|jpe?g|gif|webp|avif|svg)(\?.*)?$/i;
  const IMG_HOST_HINT= /(twimg\.com|fbcdn\.net|cdn|images|media|imgur|ggpht\.com|pinimg\.com)/i;

  function debounce(fn, ms){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }

  /* CSV helpers */
  function csvEscape(v){
    const s = (v ?? "").toString().replace(/\r?\n/g, " ").trim();
    return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
  }
  function downloadCSV(filename, rows){
    const csv = "\uFEFF" + rows.map(r => r.map(csvEscape).join(",")).join("\r\n");
    const blob = new Blob([csv], {type: "text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }

  /* Linkify plain URLs (with More/Less) */
  function linkifyWithMore(text, {alwaysShow=false} = {}){
    const m = text && text.match(URL_RE);
    if (!m) return null;
    const url = m[1];
    const frag = document.createDocumentFragment();
    const a = document.createElement("a");
    a.href = url; a.target = "_blank"; a.rel = "noopener";
    a.textContent = text; a.className = "cell-link";
    frag.appendChild(a);

    if (alwaysShow || url.length > 60) {
      const btn = document.createElement("span");
      btn.className = "moreless";
      btn.textContent = " More";
      const wrap = document.createElement("div");
      wrap.className = "full-url";
      wrap.textContent = url;

      btn.addEventListener("click", ()=>{
        const td = btn.parentElement;
        td.classList.toggle("show-full");
        btn.textContent = td.classList.contains("show-full") ? " Less" : " More";
      });

      frag.appendChild(btn);
      frag.appendChild(wrap);
    }
    return frag;
  }

  /* Twitter/X & Reddit helpers */
  function buildTwitterLinkFromHandle(txt){
    if (!txt) return null;
    const at = txt.trim();
    if (!/^@[\w.]{1,50}$/i.test(at)) return null;
    const handle = at.slice(1);
    const a = document.createElement("a");
    a.href = `https://x.com/${handle}`;
    a.target = "_blank"; a.rel = "noopener";
    a.textContent = at; a.className = "cell-link";
    return a;
  }
  function parseRedditUsername(raw) {
    if (!raw) return null;
    let s = String(raw).trim();
    s = s.replace(/^@/,'').replace(/^\/?u\//i,'');
    s = s.split(/\s+/)[0];
    if (!/^[A-Za-z0-9_]{2,25}$/.test(s)) return null;
    return s;
  }
  function buildRedditLink(raw){
    const user = parseRedditUsername(raw);
    if (!user) return null;
    const a = document.createElement("a");
    a.href = `https://www.reddit.com/user/${encodeURIComponent(user)}`;
    a.target = "_blank"; a.rel = "noopener";
    a.textContent = `u/${user}`;
    a.className = "cell-link";
    return a;
  }

  /* Phone helpers */
  function normalizeDigits(str) { return (str || "").replace(/\D+/g, ""); }
  function formatUSPhone(digits) {
    if (digits.length === 10) return `(${digits.slice(0,3)}) ${digits.slice(3,6)}-${digits.slice(6)}`;
    if (digits.length === 11 && digits[0] === '1') return `+1 (${digits.slice(1,4)}) ${digits.slice(4,7)}-${digits.slice(7)}`;
    return digits;
  }
  function buildTelAnchor(raw) {
    const d = normalizeDigits(raw);
    if (!d) return null;
    const a = document.createElement("a");
    a.href = `tel:${d.length===11 && d[0]==='1' ? '+'+d : (d.length===10 ? '+1'+d : d)}`;
    a.target = "_self";
    a.textContent = formatUSPhone(d);
    a.className = "cell-link";
    return a;
  }

  /* Avatars/favicons + Twitter helpers */
  function extractDomain(url) { try { return new URL(url).hostname; } catch { return ""; } }
  function isTwitterDomain(host){
    return /(^|\.)x\.com$/.test(host) || /(^|\.)twitter\.com$/.test(host);
  }
  function unavatarForDomain(domain) { return domain ? `https://unavatar.io/${encodeURIComponent(domain)}?fallback=false` : ""; }
  function faviconForDomain(domain) { return domain ? `https://www.google.com/s2/favicons?domain=${encodeURIComponent(domain)}&sz=128` : ""; }
  function unavatarForTwitterHandleStrict(txt) {
    const at = (txt || "").trim();
    if (!/^@[\w.]{1,50}$/i.test(at)) return [];
    const h = at.slice(1);
    return [
      `https://unavatar.io/x/${encodeURIComponent(h)}?fallback=false`,
      `https://unavatar.io/twitter/${encodeURIComponent(h)}?fallback=false`
    ];
  }
  function extractTwitterHandleFromUrlish(txt){
    const m = (txt || "").match(URL_RE);
    if (!m) return "";
    try {
      const u = new URL(m[1]);
      if (!isTwitterDomain(u.hostname)) return "";
      const parts = u.pathname.split('/').filter(Boolean);
      const handle = parts[0] || "";
      if (/^[A-Za-z0-9_]{1,50}$/.test(handle)) return `@${handle}`;
    } catch {}
    return "";
  }
  function unavatarForUrlishSkippingTwitter(txt){
    const m = txt && txt.match(URL_RE);
    if (!m) return "";
    const host = extractDomain(m[1]);
    if (!host || isTwitterDomain(host)) return "";
    return unavatarForDomain(host);
  }
  function faviconForUrlishSkippingTwitter(txt){
    const m = txt && txt.match(URL_RE);
    if (!m) return "";
    const host = extractDomain(m[1]);
    if (!host || isTwitterDomain(host)) return "";
    return faviconForDomain(host);
  }

  /* Basic helpers */
  function firstUrl(text){
    const m = (text || "").match(URL_RE);
    return m ? m[1] : "";
  }
  function preferredLandingUrl(row){
    // Click-through: E → G (no F to avoid Linktree logos)
    return firstUrl(row[E_COL_IDX]) || firstUrl(row[G_COL_IDX]) || "";
  }
  function isOnlyColAText(row){
    const colA = (row[0] || "").trim();
    if (!colA) return false;
    for (let i=1;i<row.length;i++) if ((row[i]||"").trim()!=="") return false;
    return true;
  }

  /* Cache key per row */
  function imageCacheKey(row){
    const v = (row[21]||"");
    const g = (row[G_COL_IDX]||"");
    const e = (row[E_COL_IDX]||"");
    return `ftt-imgcache:${GID}:${v}|${g}|${e}`;
  }
  function cacheGetGoodSrc(row){
    try { return localStorage.getItem(imageCacheKey(row)) || ""; } catch { return ""; }
  }
  function cacheSetGoodSrc(row, rawUrl){
    try { localStorage.setItem(imageCacheKey(row), rawUrl); } catch {}
  }

  /* Twitter profile image candidates (strict, no favicon) */
  function twitterAvatarCandidatesFromGCell(gCellText){
    const list = [];
    list.push(...unavatarForTwitterHandleStrict(gCellText));
    const h = extractTwitterHandleFromUrlish(gCellText);
    if (h) list.push(...unavatarForTwitterHandleStrict(h));
    return list;
  }

  /* Candidates — order: V → G → E (NO F) + final scan. */
  function imageCandidates(row){
    const cached = cacheGetGoodSrc(row);
    const out = [];
    if (cached) out.push(cached);

    // 1) V
    if (IMAGE_PREF_COL_IDX >= 0 && IMAGE_PREF_COL_IDX < row.length) {
      const vtxt = row[IMAGE_PREF_COL_IDX] || "";
      const vm = vtxt.match(URL_RE);
      if (vm) {
        const v = vm[1];
        if (IMG_EXT_RE.test(v) || IMG_HOST_HINT.test(v)) out.push(v);
        else {
          const genV = unavatarForUrlishSkippingTwitter(vtxt) || faviconForUrlishSkippingTwitter(vtxt);
          if (genV) out.push(genV);
        }
      }
    }

    // 2) G (strict twitter avatar) and (if non-twitter URL) site avatar
    const gStrict = twitterAvatarCandidatesFromGCell(row[G_COL_IDX]);
    if (gStrict.length) out.push(...gStrict);
    const gGen = unavatarForUrlishSkippingTwitter(row[G_COL_IDX]) || faviconForUrlishSkippingTwitter(row[G_COL_IDX]);
    if (gGen) out.push(gGen);

    // 3) E (site avatar/fav)
    const eGen = unavatarForUrlishSkippingTwitter(row[E_COL_IDX]) || faviconForUrlishSkippingTwitter(row[E_COL_IDX]);
    if (eGen) out.push(eGen);

    // Final: any direct image anywhere in row
    for (const cell of row) {
      if (!cell) continue;
      const m = cell.match(URL_RE);
      if (!m) continue;
      const url = m[1];
      if (IMG_EXT_RE.test(url) || IMG_HOST_HINT.test(url)) out.push(url);
    }

    // Dedupe
    const seen = new Set();
    return out.filter(u => { if (seen.has(u)) return false; seen.add(u); return true; });
  }

  function proxify(url){
    try {
      const noScheme = url.replace(/^https?:\/\//i,"");
      return `https://images.weserv.nl/?url=${encodeURIComponent(noScheme)}&w=${THUMB_PX}&h=${THUMB_PX}&fit=cover&q=70`;
    } catch { return url; }
  }

  /** ==== Collapse state per tab (persisted) ==== */
  function loadCollapseState(gid){
    try { return JSON.parse(localStorage.getItem(`ftt-collapse:${gid}`)) || {}; }
    catch { return {}; }
  }
  function saveCollapseState(gid, map){
    try { localStorage.setItem(`ftt-collapse:${gid}`, JSON.stringify(map)); }
    catch {}
  }

  /** ==== Show Images preference (persisted) ==== */
  function loadShowImages(){
    try {
      const v = localStorage.getItem("ftt-show-images");
      return v === null ? true : v === "true";
    } catch { return true; }
  }
  function saveShowImages(flag){
    try { localStorage.setItem("ftt-show-images", String(flag)); } catch {}
  }

  /** ==== Sorting helpers (within groups) ==== */
  function comparator(colIdx, dir){
    const mul = (dir === "desc") ? -1 : 1;
    return (ai, bi) => {
      const va = (currentRows[ai] && currentRows[ai][colIdx] || "").toString().toLowerCase();
      const vb = (currentRows[bi] && currentRows[bi][colIdx] || "").toString().toLowerCase();
      if (va < vb) return -1 * mul;
      if (va > vb) return  1 * mul;
      return 0;
    };
  }

  /** ==== Data fetchers (GViz first, CSV fallback) ==== */
  function gvizURL(fileId, gid, range){
    const u = new URL(`https://docs.google.com/spreadsheets/d/${fileId}/gviz/tq`);
    u.searchParams.set("gid", gid);
    u.searchParams.set("range", range);
    u.searchParams.set("tqx", "out:json");
    u.searchParams.set("_", Date.now());
    return u.toString();
  }
  function csvURL(fileId, gid){
    const u = new URL(`https://docs.google.com/spreadsheets/d/${fileId}/export`);
    u.searchParams.set("format", "csv");
    u.searchParams.set("gid", gid);
    u.searchParams.set("_", Date.now());
    return u.toString();
  }

  function parseGViz(text){
    // Strip JS wrapper to get the JSON object
    const jsonStr = text.replace(/^[^{]+/, "").replace(/[^}]+$/, "");
    return JSON.parse(jsonStr);
  }

  function parseCSV(text){
    // Simple CSV parser supporting quotes and commas
    const rows = [];
    let i=0, field="", row=[], inQuotes=false;
    while (i < text.length){
      const ch = text[i++];
      if (inQuotes){
        if (ch === '"'){
          if (text[i] === '"'){ field += '"'; i++; }
          else inQuotes = false;
        } else {
          field += ch;
        }
      } else {
        if (ch === '"'){ inQuotes = true; }
        else if (ch === ','){ row.push(field); field=""; }
        else if (ch === '\n' || ch === '\r'){
          if (ch === '\r' && text[i] === '\n') i++; // CRLF
          row.push(field); rows.push(row); row=[]; field="";
        } else {
          field += ch;
        }
      }
    }
    if (field.length || row.length) { row.push(field); rows.push(row); }
    return rows;
  }

  async function fetchViaGViz(gid){
    const url = gvizURL(FILE_ID, gid, RANGE);
    dbg.textContent = `GViz: ${url}`;
    const res  = await fetch(url, { cache: "no-store" });
    const text = await res.text();
    if (!res.ok) throw new Error(`GViz HTTP ${res.status}`);
    if (/You need access|Sign in|login/i.test(text)) {
      throw new Error("GViz says: spreadsheet is not publicly accessible.");
    }
    const fixed = parseGViz(text);
    const rows = (fixed.table?.rows || []).map(r =>
      (r.c || []).map(cell => {
        if (!cell) return "";
        const v = (cell.f ?? cell.v);
        return v == null ? "" : String(v);
      })
    );
    const cols = (fixed.table?.cols || []);
    const colCount = Math.max(cols.length, ...rows.map(r => r.length), MAX_SHOW_COL_IDX+1, 0);
    rows.forEach(r => { while (r.length < colCount) r.push(""); });
    return { rows, colCount, src: "gviz" };
  }

  async function fetchViaCSV(gid){
    const url = csvURL(FILE_ID, gid);
    dbg.textContent = `CSV: ${url}`;
    const res  = await fetch(url, { cache: "no-store" });
    const text = await res.text();
    if (!res.ok) throw new Error(`CSV HTTP ${res.status}`);
    if (/HTML|<title>|Sign in|You need access/i.test(text)) {
      throw new Error("CSV says: spreadsheet is not publicly accessible.");
    }
    const raw = parseCSV(text);
    // Pad to MAX_SHOW_COL_IDX+1
    const colCount = Math.max(...raw.map(r => r.length), MAX_SHOW_COL_IDX+1, 0);
    const rows = raw.map(r => {
      const arr = r.map(x => String(x ?? ""));
      while (arr.length < colCount) arr.push("");
      return arr;
    });
    return { rows, colCount, src: "csv" };
  }

  async function fetchRectFor(gid){
    // Try GViz, then CSV
    try {
      const pack = await fetchViaGViz(gid);
      meta.classList.remove("error");
      return pack;
    } catch (e1){
      console.warn("GViz failed, trying CSV:", e1);
      meta.classList.add("error");
      meta.textContent = `GViz failed (${e1.message}). Trying CSV…`;
      try {
        const pack = await fetchViaCSV(gid);
        meta.classList.remove("error");
        return pack;
      } catch (e2){
        meta.classList.add("error");
        meta.textContent = `Both GViz and CSV failed. Check sheet sharing (“Anyone with link – Viewer”).`;
        throw e2;
      }
    }
  }
  async function fetchRect(){ return fetchRectFor(GID); }

  /** ==== Column widths ==== */
  function buildColgroup(){
    colg.innerHTML = "";
    const widths = [160];
    for (let i=0;i<=MAX_SHOW_COL_IDX;i++){
      let w = 150;
      if (i < 3) w = 170;
      if (WIDE_IDX.includes(i)) w = 280;
      widths.push(w);
    }
    widths.forEach(px => {
      const col = document.createElement("col");
      col.style.width = px + "px";
      colg.appendChild(col);
    });
  }

  /** ==== Build groups from state headers ==== */
  function buildGroups(rows){
    const state = loadCollapseState(GID);
    const groups = [];
    let current = null;
    for (let i=0; i<rows.length; i++){
      const row = rows[i];
      if (isOnlyColAText(row)) {
        const name = (row[0]||"").trim() || "Untitled";
        current = { headerIndex: i, stateName: name, members: [], collapsed: (state[name] !== undefined ? state[name] : true) };
        groups.push(current);
      } else if (current) {
        current.members.push(i);
      }
    }
    return groups;
  }
  function persistGroups(groups){
    const map = {};
    for (const g of groups) map[g.stateName] = g.collapsed;
    saveCollapseState(GID, map);
  }

  /** ==== Helpers: global clamp for text cells ==== */
  function makeTextCell(td, text){
    const wrapper = document.createElement("div");
    wrapper.className = "clamp-wrap clamp-3";
    wrapper.textContent = text ?? "";
    td.appendChild(wrapper);
    requestAnimationFrame(()=>{
      if (wrapper.scrollHeight > wrapper.clientHeight + 1) {
        const btn = document.createElement("span");
        btn.className = "moreless";
        btn.textContent = " More";
        btn.addEventListener("click", ()=>{
          wrapper.classList.toggle("clamp-3");
          btn.textContent = wrapper.classList.contains("clamp-3") ? " More" : " Less";
        });
        td.appendChild(btn);
      }
    });
  }

  /** ==== Build image cell on demand (used at render-time AND on expand) ==== */
  function buildImageCell(tdImg, row, rIdx){
    if (!imgToggle.checked) return;
    if (tdImg._imgReady) return; // avoid rebuilding
    tdImg._imgReady = true;

    const cands = imgCandCache.get(rIdx) || imageCandidates(row);
    imgCandCache.set(rIdx, cands);

    if (!cands.length) return;

    const sk  = document.createElement("div"); sk.className = "skeleton";
    const img = document.createElement("img"); img.className = "thumb"; img.loading="lazy"; img.decoding="async";

    let i = 0, timeoutId = null;
    function clearTimer(){ if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; } }
    function tryNext(){
      clearTimer();
      if (i >= cands.length) { sk.remove(); tdImg.textContent = ""; doneOne(); return; }
      const raw = cands[i++];
      img._rawSrc = raw;
      const src = proxify(raw);
      img.src = "";
      img.src = src;
      timeoutId = setTimeout(()=>img.onerror && img.onerror(), IMG_TIMEOUT_MS);
    }
    img.onerror = ()=>{ clearTimer(); tryNext(); };
    img.onload  = () => {
      clearTimer();
      if ((img.naturalWidth||0) < 48 || (img.naturalHeight||0) < 48) { tryNext(); return; }
      cacheSetGoodSrc(row, img._rawSrc || "");
      sk.remove();
      doneOne();
    };

    const starter = ()=>{ tryNext(); };
    img._startLoading = starter;
    lazyImgObserver.observe(img);

    const landing = preferredLandingUrl(row);
    if (landing) {
      const a = document.createElement("a");
      a.href = landing; a.target = "_blank"; a.rel = "noopener"; a.title = "Open link";
      a.appendChild(sk); a.appendChild(img);
      tdImg.appendChild(a);
    } else {
      tdImg.appendChild(sk); tdImg.appendChild(img);
    }
  }

  /** ==== Render (with per-group sort) ==== */
