<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FTT Big List</title>

  <!-- Performance hints -->
  <link rel="preconnect" href="https://unavatar.io" crossorigin>
  <link rel="preconnect" href="https://www.google.com" crossorigin>
  <link rel="preconnect" href="https://images.weserv.nl" crossorigin>
  <link rel="dns-prefetch" href="//unavatar.io">
  <link rel="dns-prefetch" href="//images.weserv.nl">
  <link rel="dns-prefetch" href="//www.google.com">

  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    :root{
      --brand:#0078d7;
      --bg:#f4f7fa;
      --panel:#fff;
      --text:#222;
      --line:#e9eef4;
      --line-2:#e0e6ee;
      --accent:#0063b1;
      --state:#000;
    }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: flex; flex-direction: column;
    }

    header { display: grid; gap: 8px; padding: 10px 12px; background: var(--brand); color: #fff; box-shadow: 0 1px 2px rgba(0,0,0,.08); }
    header .top { display:flex; gap:12px; align-items:center; }
    h1 { margin:0; font-size:15px; font-weight:800; line-height:1.1; letter-spacing:.2px; }
    .meta { margin-left:auto; font-size:12px; opacity:.95; background: #ffffff1a; padding:4px 8px; border-radius:8px; }

    .button-row { display:flex; flex-wrap:wrap; gap:6px; }
    .btn { color:#fff; background:#0063b1; border:0; border-radius:10px; padding:.40rem .65rem; font-weight:700; font-size:13px; cursor:pointer; transition:transform .05s ease, filter .2s ease; }
    .btn:active{ transform: translateY(1px); }
    .btn.us{background:#0078d7}.btn.canada{background:#d83b01}.btn.samerica{background:#107c10}
    .btn.europe{background:#6b46c1}.btn.eastasia{background:#e81123}.btn.mideast{background:#ffb900;color:#333}
    .btn.active{outline:2px solid #fff; outline-offset:1px; filter:brightness(1.06)}

    .controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; font-size:12px; justify-content:flex-start; }
    .controls input[type="search"]{ padding:8px 10px; border-radius:10px; border:1px solid #c8d7eb; min-width:260px; outline: none; background:#fff; }
    .controls .btn { font-size:12px; padding:.45rem .65rem; border-radius:10px; border:none; }

    main { display:flex; flex-direction:column; }
    .table-wrap { height: calc(100vh - 194px); overflow:auto; background:var(--panel); border-top:1px solid var(--line); border-bottom:1px solid var(--line); }

    table { border-collapse: separate; border-spacing: 0; width: 100%; table-layout: fixed; font-size: 14px; min-width: 2200px; }
    tbody td {
      border-bottom:1px solid #f0f3f6; padding:8px 10px; vertical-align: top;
      white-space: normal; overflow-wrap: break-word; word-break: normal; hyphens: manual; line-height:1.35;
      background: var(--panel);
    }
    tbody tr:nth-child(2n){ background:#fafcff; }

    /* Row 1 hidden; Row 2 sticky */
    tbody tr.is-hidden { display: none; }
    tbody tr.sticky-second td {
      position: sticky; top: 0; z-index: 4;
      background: linear-gradient(#f7fafc, #eef3f9);
      border-bottom: 2px solid var(--line-2);
    }

    /* Sortable cells on the pinned header row (row 2) */
    .sticky-second .hdr-sort {
      display:inline-flex; align-items:center; gap:6px; font-weight:800; cursor:pointer; user-select:none; padding:2px 4px; border-radius:8px;
    }
    .sticky-second .hdr-sort:hover { background:#e9eef7; }
    .sort-caret{ font-size:12px; opacity:.75; }
    .sorted-asc .sort-caret::after{ content:"▲"; }
    .sorted-desc .sort-caret::after{ content:"▼"; }
    .sorted-none .sort-caret::after{ content:"↕"; opacity:.5; }

    /* State header row */
    tr.state-header > td {
      background: var(--state) !important; color:#fff !important;
      font-weight: 800; letter-spacing: .2px;
      border-bottom: 2px solid #111;
      position: sticky; top: 40px; z-index: 3;
    }
    tr.state-header .state-bar { display:flex; align-items:center; gap:10px; cursor: pointer; padding:6px 0; }
    .chev {
      width: 0; height: 0;
      border-left: 6px solid currentColor;
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
      transition: transform .15s ease;
    }
    .expanded .chev { transform: rotate(90deg); }
    tr[data-collapsed="true"] { display: none; }

    /* Image column + hiding */
    .imgCol { width: 160px; }
    .thumb  { width: 120px; height: 120px; border-radius:12px; border:1px solid #ececec; object-fit:cover; display:block; background:#f1f1f1; }
    .skeleton { width: 120px; height: 120px; background:linear-gradient(90deg,#eee,#f5f5f5,#eee); background-size:200% 100%; animation:shimmer 1s linear infinite; border-radius:12px; border:1px solid #ececec; }
    @keyframes shimmer{0%{background-position:0% 0}100%{background-position:200% 0}}
    .hide-images .imgCol { display:none; }

    /* Links */
    td a { white-space: nowrap; display:inline-block; max-width:100%; overflow:hidden; text-overflow:ellipsis; }
    .cell-link { color: inherit; text-decoration: underline; }
    .full-url { display:none; margin-top:6px; font-size:12px; color:#333; word-break: break-all; white-space: normal; background:#f6f8fb; border:1px solid #e5ebf3; border-radius:8px; padding:6px; }
    .show-full .full-url { display:block; }

    /* Global text clamp + More/Less */
    .clamp-wrap { display:-webkit-box; -webkit-box-orient:vertical; overflow:hidden; }
    .clamp-3 { -webkit-line-clamp:3; }
    .moreless { display:inline-block; margin-top:6px; font-size:12px; color:var(--accent); cursor:pointer; user-select:none; }

    /* Search hide */
    .search-row-hide { display: none !important; }

    /* Tiny icon cells (Column I) */
    .sentiment { font-size:18px; line-height:1; }

    .footer-actions{ padding:8px 12px; display:flex; gap:8px; align-items:center; color:#4b5563; font-size:12px; flex-wrap: wrap;}
    .linkish{ color:#0a5a7a; cursor:pointer; text-decoration:underline; }

    /* New: subtle badge inside the Price cell */
    .price-badge{
      display:inline-block;
      font-size:12px;
      margin-left:6px;
      padding:2px 6px;
      border-radius:8px;
      background:#eef4ff;
      border:1px solid #d9e5ff;
      white-space:nowrap;
    }

    /* Download button look */
    .btn.download { background:#1f7a1f; }
  </style>
</head>
<body>
  <header>
    <div class="top">
      <h1>FTT Big List</h1>
      <div class="meta" id="meta">loading…</div>
    </div>

    <div class="button-row" role="navigation" aria-label="Tabs">
      <button class="btn us active"      data-gid="0">United States</button>
      <button class="btn canada"         data-gid="918890863">Canada</button>
      <button class="btn samerica"       data-gid="506975496">South America + Caribbean</button>
      <button class="btn europe"         data-gid="1560092023">Europe + Nordic</button>
      <button class="btn eastasia"       data-gid="1966795654">East Asia + Oceania + Australia</button>
      <button class="btn mideast"        data-gid="1604960979">Middle East</button>
    </div>

    <div class="controls">
      <input id="searchBox" type="search" placeholder="Search…" />
      <button id="clearSearch" class="btn" style="background:#666">Clear</button>

      <label class="switch" title="Toggle row thumbnails">
        <input id="imgToggle" type="checkbox" />
        Show images
      </label>

      <button id="expandAll" class="btn" style="background:#3aa655">Expand all</button>
      <button id="collapseAll" class="btn" style="background:#b83d3d">Collapse all</button>
    </div>
  </header>

  <main>
    <div class="table-wrap" id="scrollWrap">
      <table id="tbl" aria-live="polite">
        <colgroup id="colg"></colgroup>
        <tbody id="tbody"></tbody>
      </table>
    </div>
    <div class="footer-actions">
      <span class="linkish" id="resetSort">Reset sorting</span>
      <button id="downloadCsvBtn" class="btn download">⬇️ Download CSV</button>
    </div>
  </main>

  <script>
  /** ==== CONFIG ==== */
  const FILE_ID = "1hse75kxI9Gcb7g_tc9LOZ5dYVkFgDcNCrLKyq03cnHg";
  let   GID     = "0";
  const RANGE   = "A1:AA50000";
  const MAX_SHOW_COL_LETTER = "S";
  const MAX_SHOW_COL_IDX = colLetterToIdx(MAX_SHOW_COL_LETTER);

  const TABS = [
    { name: "United States", gid: "0" },
    { name: "Canada", gid: "918890863" },
    { name: "South America + Caribbean", gid: "506975496" },
    { name: "Europe + Nordic", gid: "1560092023" },
    { name: "East Asia + Oceania + Australia", gid: "1966795654" },
    { name: "Middle East", gid: "1604960979" },
  ];

  const ACTIVE_GID_KEY = "ftt-active-gid";
  const SCROLL_KEY_PREFIX = "ftt-scroll:"; // + GID
  const SORT_KEY_PREFIX   = "ftt-sort:";   // + GID

  /* Wider columns — add Website (E) */
  const WIDE_COLS = ["E","K","R"];
  const WIDE_IDX  = WIDE_COLS.map(colLetterToIdx);

  /* Image pref column (V) */
  const IMAGE_PREF_COL_LETTER = "V";
  const IMAGE_PREF_COL_IDX = colLetterToIdx(IMAGE_PREF_COL_LETTER);

  /* Column indexes (A=0) */
  const A_COL_IDX = 0, B_COL_IDX = 1;
  const E_COL_IDX = 4, F_COL_IDX = 5, G_COL_IDX = 6, H_COL_IDX = 7, I_COL_IDX = 8, J_COL_IDX = 9, P_COL_IDX = 15, Q_COL_IDX = 16;

  /* Sortable header labels on the sticky header row */
  const SORTABLE_HEADERS = new Map([
    ["Location","A"],
    ["Alternative Location","B"],
    ["Domme","C"],
    ["Verified?","H"],
    ["Experience?","I"],
    ["Price range?","J"],
  ]);

  let POLL_MS = 120000;
  let ROW_CAP = 2000;
  const THUMB_PX = 120;

  const MAX_CONCURRENT_IMG = 8;
  const IMG_TIMEOUT_MS = 3000;
  const LAZY_ROOT_MARGIN = '1200px 0px';

  const COL_HEADERS = [
    "Location","Alternative Location","Domme","Images/Aliases","Website","Link tree/All links",
    "X/BlueSky","Verified?","Experience?","Price range?","Review/notes","Renown",
    "Link to full review","Travels?","email","Reddit","phone","Services Provided","link"
  ];

  /** ==== DOM ==== */
  const $  = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));
  const tbody = $("#tbody");
  const colg  = $("#colg");
  const meta  = $("#meta");
  const imgToggle = $("#imgToggle");
  const expandAllBtn = $("#expandAll");
  const collapseAllBtn = $("#collapseAll");
  const searchBox = $("#searchBox");
  const clearSearchBtn = $("#clearSearch");
  const resetSortBtn = $("#resetSort");
  const downloadCsvBtn = $("#downloadCsvBtn");
  const scrollWrap = $("#scrollWrap");

  /** ==== State ==== */
  let currentRows = [];
  let currentColCount = 0;
  let sortSpec = null; // { colIdx, dir: 'asc'|'desc' }
  let lastQuery = "";
  let imgCandCache = new Map();
  let rowTextIndex = new Map(); // rIdx -> lowercased full text for searching

  /** ==== Concurrency limiter for images ==== */
  let inflight = 0;
  const pendingStarts = [];
  function schedule(startFn){
    if (inflight < MAX_CONCURRENT_IMG){ inflight++; startFn(); }
    else { pendingStarts.push(startFn); }
  }
  function doneOne(){
    inflight = Math.max(0, inflight - 1);
    if (pendingStarts.length){ const fn = pendingStarts.shift(); inflight++; fn(); }
  }

  /** ==== Lazy image observer ==== */
  const lazyImgObserver = new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{
      if (!entry.isIntersecting) return;
      const starter = entry.target._startLoading;
      if (starter) schedule(starter);
      lazyImgObserver.unobserve(entry.target);
    });
  }, { root: scrollWrap, rootMargin: LAZY_ROOT_MARGIN, threshold: 0.01 });

  /** ==== Utilities ==== */
  function colLetterToIdx(letter){ let n=0; for(let i=0;i<letter.length;i++) n=n*26+(letter.charCodeAt(i)-64); return n-1; }
  const URL_RE = /(https?:\/\/[^\s)'"<>]+)/i;
  const IMG_EXT_RE   = /\.(png|jpe?g|gif|webp|avif|svg)(\?.*)?$/i;
  const IMG_HOST_HINT= /(twimg\.com|fbcdn\.net|cdn|images|media|imgur|ggpht\.com|pinimg\.com)/i;
  function debounce(fn, ms){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }
  function csvEscape(v){ const s=(v??"").toString().replace(/\r?\n/g," ").trim(); return /[",\n]/.test(s)?`"${s.replace(/"/g,'""')}"`:s; }
  function downloadCSV(filename, rows){
    const csv = "\uFEFF" + rows.map(r => r.map(csvEscape).join(",")).join("\r\n");
    const blob = new Blob([csv], {type: "text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a"); a.href=url; a.download=filename; document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }
  function extractFirstNumber(s){
    if (!s) return Number.POSITIVE_INFINITY;
    const m = String(s).replace(/,/g,'').match(/(\d+(\.\d+)?)/);
    return m ? parseFloat(m[1]) : Number.POSITIVE_INFINITY;
  }
  function norm(s){ return (s||"").toString().trim().toLowerCase(); }

  /* New helpers: numeric price & smart pretty URL text */
  function extractNumbers(s){
    if (!s) return [];
    const m = String(s).replace(/,/g,'').match(/\d+(\.\d+)?/g);
    return m ? m.map(Number) : [];
  }
  function computePriceNumber(s){
    const nums = extractNumbers(s);
    if (!nums.length) return NaN;
    if (nums.length === 1) return nums[0];
    return nums.reduce((a,b)=>a+b,0) / nums.length;
  }
  function prettyUrlText(url){
    const fallback = (s) => String(s)
      .replace(/^https?:\/\//i,'')
      .replace(/^www\./i,'')
      .replace(/\/+$/,''); // trim trailing '/'
    try {
      const u = new URL(url);
      const host = (u.hostname || "").replace(/^www\./i,'');
      const rawPath = (u.pathname || "").replace(/\/+$/,'');
      if (!rawPath || rawPath === "/") return host;
      const parts = rawPath.split('/').filter(Boolean);
      const usernameHosts = /^(allmylinks\.com|linktr\.ee|beacons\.ai|carrd\.co|stan\.store|onlyfans\.com|fansly\.com|manyvids\.com|patreon\.com|ko-fi\.com)$/i;
      const usernameLike = /^[A-Za-z0-9._-]{2,}$/;
      if (usernameHosts.test(host)) {
        return `${host}/${parts[0]}`;
      }
      if (parts.length === 1 && usernameLike.test(parts[0])) {
        return `${host}/${parts[0]}`;
      }
      if (parts.length === 2 && usernameLike.test(parts[0]) && parts[1].length <= 20) {
        return `${host}/${parts[0]}/${parts[1]}`;
      }
      const last = parts[parts.length - 1];
      return `${host}/…/${last}`;
    } catch {
      return fallback(url);
    }
  }

  /* Price range ranking (kept; not used for sorting anymore) */
  function priceRank(s){
    const t = norm(s);
    if (!t || t.includes("unknown")) return Number.POSITIVE_INFINITY;
    const hasLow = t.includes("low");
    const hasMid = t.includes("mid");
    const hasHighMid = t.includes("high mid") || t.includes("high-mid") || t.includes("mid high") || t.includes("mid-high");
    const hasHigh = t.includes("high");
    if (hasLow && !hasMid) return 0;
    if (hasLow && hasMid)  return 1;
    if (!hasLow && hasMid && !hasHighMid) return 2;
    if (hasHighMid) return 3;
    if (hasHigh) return 4;
    return 5;
  }

  /* Verified ranking */
  function verifiedRank(s){
    const t = norm(s);
    if (!t) return 9;
    if (t.includes("scam")) return 8;
    if (t.includes("admin verified")) return 0;
    if (t.includes("reddit verified")) return 1;
    if (t.includes("fetlife verified")) return 2;
    if (/\bverified\b/.test(t)) return 3;
    if (t.includes("seems legit")) return 4;
    if (t.includes("needs verification")) return 5;
    if (t.includes("mixed")) return 6;
    return 7;
  }

  /* Experience ranking */
  function experienceRank(s){
    const t = norm(s);
    if (!t) return 6;
    if (t.includes("positive")) return 0;
    if (t.includes("neutral"))  return 1;
    if (t.includes("mixed"))    return 2;
    if (t.includes("needs review")) return 3;
    if (t.includes("negative")) return 4;
    return 5;
  }

  /* Basic helpers */
  function firstUrl(text){ const m=(text||"").match(URL_RE); return m?m[1]:""; }
  function preferredLandingUrl(row){ return firstUrl(row[E_COL_IDX]) || firstUrl(row[G_COL_IDX]) || ""; }
  function isOnlyColAText(row){
    const colA = (row[0] || "").trim(); if (!colA) return false;
    for (let i=1;i<row.length;i++) if ((row[i]||"").trim()!=="") return false; return true;
  }

  /* Cache key per row */
  function imageCacheKey(row){
    const v = (row[21]||""); const g = (row[G_COL_IDX]||""); const e = (row[E_COL_IDX]||"");
    return `ftt-imgcache:${GID}:${v}|${g}|${e}`;
  }
  function cacheGetGoodSrc(row){ try { return localStorage.getItem(imageCacheKey(row)) || ""; } catch { return ""; } }
  function cacheSetGoodSrc(row, rawUrl){ try { localStorage.setItem(imageCacheKey(row), rawUrl); } catch {} }

  /* Twitter/avatar helpers */
  function extractDomain(url) { try { return new URL(url).hostname; } catch { return ""; } }
  function isTwitterDomain(host){ return /(^|\.)x\.com$/.test(host) || /(^|\.)twitter\.com$/.test(host); }
  function unavatarForDomain(domain) { return domain ? `https://unavatar.io/${encodeURIComponent(domain)}?fallback=false` : ""; }
  function faviconForDomain(domain) { return domain ? `https://www.google.com/s2/favicons?domain=${encodeURIComponent(domain)}&sz=128` : ""; }
  function unavatarForTwitterHandleStrict(txt) {
    const at = (txt || "").trim(); if (!/^@[\w.]{1,50}$/i.test(at)) return [];
    const h = at.slice(1);
    return [
      `https://unavatar.io/x/${encodeURIComponent(h)}?fallback=false`,
      `https://unavatar.io/twitter/${encodeURIComponent(h)}?fallback=false`
    ];
  }
  function extractTwitterHandleFromUrlish(txt){
    const m = (txt || "").match(URL_RE); if (!m) return "";
    try {
      const u = new URL(m[1]); if (!isTwitterDomain(u.hostname)) return "";
      const parts = u.pathname.split('/').filter(Boolean);
      const handle = parts[0] || "";
      if (/^[A-Za-z0-9_]{1,50}$/.test(handle)) return `@${handle}`;
    } catch {}
    return "";
  }
  function unavatarForUrlishSkippingTwitter(txt){
    const m = txt && txt.match(URL_RE); if (!m) return "";
    const host = extractDomain(m[1]); if (!host || isTwitterDomain(host)) return "";
    return unavatarForDomain(host);
  }
  function faviconForUrlishSkippingTwitter(txt){
    const m = txt && txt.match(URL_RE); if (!m) return "";
    const host = extractDomain(m[1]); if (!host || isTwitterDomain(host)) return "";
    return faviconForDomain(host);
  }

  /* Image candidates */
  function imageCandidates(row){
    const cached = cacheGetGoodSrc(row); const out = []; if (cached) out.push(cached);
    if (IMAGE_PREF_COL_IDX >= 0 && IMAGE_PREF_COL_IDX < row.length) {
      const vtxt = row[IMAGE_PREF_COL_IDX] || ""; const vm = vtxt.match(URL_RE);
      if (vm) {
        const v = vm[1];
        if (IMG_EXT_RE.test(v) || IMG_HOST_HINT.test(v)) out.push(v);
        else {
          const genV = unavatarForUrlishSkippingTwitter(vtxt) || faviconForUrlishSkippingTwitter(vtxt);
          if (genV) out.push(genV);
        }
      }
    }
    const gStrict = unavatarForTwitterHandleStrict(row[G_COL_IDX])
      .concat(unavatarForTwitterHandleStrict(extractTwitterHandleFromUrlish(row[G_COL_IDX])));
    if (gStrict.length) out.push(...gStrict);
    const gGen = unavatarForUrlishSkippingTwitter(row[G_COL_IDX]) || faviconForUrlishSkippingTwitter(row[G_COL_IDX]); if (gGen) out.push(gGen);
    const eGen = unavatarForUrlishSkippingTwitter(row[E_COL_IDX]) || faviconForUrlishSkippingTwitter(row[E_COL_IDX]); if (eGen) out.push(eGen);
    for (const cell of row) {
      if (!cell) continue; const m = cell.match(URL_RE); if (!m) continue;
      const url = m[1]; if (IMG_EXT_RE.test(url) || IMG_HOST_HINT.test(url)) out.push(url);
    }
    const seen = new Set(); return out.filter(u => { if (seen.has(u)) return false; seen.add(u); return true; });
  }
  function proxify(url){
    try { const noScheme = url.replace(/^https?:\/\//i,""); return `https://images.weserv.nl/?url=${encodeURIComponent(noScheme)}&w=${THUMB_PX}&h=${THUMB_PX}&fit=cover&q=70`; }
    catch { return url; }
  }

  /** ==== Persist collapse/show images/sort ==== */
  function loadCollapseState(gid){ try { return JSON.parse(localStorage.getItem(`ftt-collapse:${gid}`)) || {}; } catch { return {}; } }
  function saveCollapseState(gid, map){ try { localStorage.setItem(`ftt-collapse:${gid}`, JSON.stringify(map)); } catch {} }
  function loadShowImages(){ try { const v=localStorage.getItem("ftt-show-images"); return v===null?true:v==="true"; } catch { return true; } }
  function saveShowImages(flag){ try { localStorage.setItem("ftt-show-images", String(flag)); } catch {} }
  function persistSort(gid, spec){ try { localStorage.setItem(SORT_KEY_PREFIX + gid, JSON.stringify(spec||null)); } catch {} }
  function loadSort(gid){ try { const v=localStorage.getItem(SORT_KEY_PREFIX + gid); return v?JSON.parse(v):null; } catch { return null; } }

  /** ==== Sorting helpers (within groups) ==== */
  function comparator(colIdx, dir){
    const mul = (dir === "desc") ? -1 : 1;
    return (ai, bi) => {
      const a = (currentRows[ai] && currentRows[ai][colIdx] || "");
      const b = (currentRows[bi] && currentRows[bi][colIdx] || "");
      if (colIdx === J_COL_IDX){
        // NEW: numeric sort for price
        const na = computePriceNumber(a), nb = computePriceNumber(b);
        const aValid = Number.isFinite(na), bValid = Number.isFinite(nb);
        if (aValid && bValid) return (na < nb ? -1 : na > nb ? 1 : 0) * mul;
        if (aValid && !bValid) return -1; // numbers first
        if (!aValid && bValid) return 1;
        const ta = norm(a), tb = norm(b);
        if (ta < tb) return -1 * mul; if (ta > tb) return 1 * mul; return 0;
      }
      if (colIdx === H_COL_IDX){
        const scamA = norm(a).includes("scam"), scamB = norm(b).includes("scam");
        if (scamA && !scamB) return 1;
        if (scamB && !scamA) return -1;
        const ra = verifiedRank(a), rb = verifiedRank(b);
        if (ra !== rb) return (ra < rb) ? -1 : 1;
        const ta = norm(a), tb = norm(b);
        if (!ta && tb) return 1; if (!tb && ta) return -1;
        if (ta < tb) return -1 * mul; if (ta > tb) return 1 * mul; return 0;
      }
      if (colIdx === I_COL_IDX){
        const ra = experienceRank(a), rb = experienceRank(b);
        if (ra !== rb) return (ra < rb) ? -1 : 1;
        const ta = norm(a), tb = norm(b);
        if (!ta && tb) return 1; if (!tb && ta) return -1;
        if (ta < tb) return -1 * mul; if (ta > tb) return 1 * mul; return 0;
      }
      const ta = norm(a), tb = norm(b);
      if (!ta && tb) return 1;
      if (!tb && ta) return -1;
      if (ta < tb) return -1 * mul;
      if (ta > tb) return  1 * mul;
      return 0;
    };
  }

  /** ==== GViz fetch ==== */
  function gvizURL(fileId, gid, range){
    const u = new URL(`https://docs.google.com/spreadsheets/d/${fileId}/gviz/tq`);
    u.searchParams.set("gid", gid);
    u.searchParams.set("range", range);
    u.searchParams.set("tqx", "out:json");
    u.searchParams.set("_", Date.now());
    return u.toString();
  }
  async function fetchRectFor(gid){
    const res  = await fetch(gvizURL(FILE_ID, gid, RANGE), { cache: "no-store" });
    const text = await res.text();
    const fixed = JSON.parse(text.replace(/^[^{]+/, "").replace(/[^}]+$/, ""));
    const rows = (fixed.table?.rows || []).map(r =>
      (r.c || []).map(cell => {
        if (!cell) return "";
        const v = (cell.f ?? cell.v);
        return v == null ? "" : String(v);
      })
    );
    const cols = (fixed.table?.cols || []);
    const colCount = Math.max(cols.length, ...rows.map(r => r.length), MAX_SHOW_COL_IDX+1, 0);
    rows.forEach(r => { while (r.length < colCount) r.push(""); });
    return { rows, colCount };
  }
  async function fetchRect(){ return fetchRectFor(GID); }

  /** ==== Colgroup widths ==== */
  function buildColgroup(){
    colg.innerHTML = "";
    const widths = [160]; // image column
    for (let i=0;i<=MAX_SHOW_COL_IDX;i++){
      let w = 150;
      if (i < 3) w = 170;
      if (WIDE_IDX.includes(i)) w = 280;
      if (i === E_COL_IDX) w = 360; // Website gets extra width
      widths.push(w);
    }
    widths.forEach(px => {
      const col = document.createElement("col");
      col.style.width = px + "px";
      colg.appendChild(col);
    });
  }

  /** ==== Grouping ==== */
  function loadCollapseStateMap(){ return loadCollapseState(GID); }
  function buildGroups(rows){
    const state = loadCollapseStateMap();
    const groups = []; let current = null;
    for (let i=0; i<rows.length; i++){
      const row = rows[i];
      if (isOnlyColAText(row)) {
        const name = (row[0]||"").trim() || "Untitled";
        current = { headerIndex: i, stateName: name, members: [], collapsed: (state[name] !== undefined ? state[name] : true) };
        groups.push(current);
      } else if (current) {
        current.members.push(i);
      }
    }
    return groups;
  }
  function persistGroups(groups){
    const map = {}; for (const g of groups) map[g.stateName] = g.collapsed; saveCollapseState(GID, map);
  }

  /** ==== Cells helpers ==== */
  function makeTextCell(td, text){
    const wrapper = document.createElement("div");
    wrapper.className = "clamp-wrap clamp-3";
    wrapper.textContent = text ?? "";
    td.appendChild(wrapper);
    requestAnimationFrame(()=>{
      if (wrapper.scrollHeight > wrapper.clientHeight + 1) {
        const btn = document.createElement("span");
        btn.className = "moreless"; btn.textContent = " More";
        btn.addEventListener("click", ()=>{
          wrapper.classList.toggle("clamp-3");
          btn.textContent = wrapper.classList.contains("clamp-3") ? " More" : " Less";
        });
        td.appendChild(btn);
      }
    });
  }
  function linkifyWithMore(text, {alwaysShow=false, pretty=false} = {}){
    const m = text && text.match(URL_RE); if (!m) return null;
    const url = m[1]; const frag = document.createDocumentFragment();
    const a = document.createElement("a");
    a.href = url; a.target = "_blank"; a.rel = "noopener";
    a.textContent = pretty ? prettyUrlText(url) : text; a.className = "cell-link";
    frag.appendChild(a);
    if (alwaysShow || url.length > 60) {
      const btn = document.createElement("span"); btn.className = "moreless"; btn.textContent = " More";
      const wrap = document.createElement("div"); wrap.className = "full-url"; wrap.textContent = url;
      btn.addEventListener("click", ()=>{
        const td = btn.parentElement; td.classList.toggle("show-full");
        btn.textContent = td.classList.contains("show-full") ? " Less" : " More";
      });
      frag.appendChild(btn); frag.appendChild(wrap);
    }
    return frag;
  }
  function buildTwitterLinkFromHandle(txt){
    if (!txt) return null; const at = txt.trim(); if (!/^@[\w.]{1,50}$/i.test(at)) return null;
    const handle = at.slice(1); const a = document.createElement("a");
    a.href = `https://x.com/${handle}`; a.target = "_blank"; a.rel = "noopener"; a.textContent = at; a.className = "cell-link";
    return a;
  }
  function parseRedditUsername(raw) {
    if (!raw) return null; let s = String(raw).trim(); s = s.replace(/^@/,'').replace(/^\/?u\//i,''); s = s.split(/\s+/)[0];
    if (!/^[A-Za-z0-9_]{2,25}$/.test(s)) return null; return s;
  }
  function buildRedditLink(raw){
    const user = parseRedditUsername(raw); if (!user) return null;
    const a = document.createElement("a");
    a.href = `https://www.reddit.com/user/${encodeURIComponent(user)}`; a.target = "_blank"; a.rel = "noopener";
    a.textContent = `u/${user}`; a.className = "cell-link"; return a;
  }
  function normalizeDigits(str) { return (str || "").replace(/\D+/g, ""); }
  function formatUSPhone(digits) {
    if (digits.length === 10) return `(${digits.slice(0,3)}) ${digits.slice(3,6)}-${digits.slice(6)}`;
    if (digits.length === 11 && digits[0] === '1') return `+1 (${digits.slice(1,4)}) ${digits.slice(4,7)}-${digits.slice(7)}`;
    return digits;
  }
  function buildTelAnchor(raw) {
    const d = normalizeDigits(raw); if (!d) return null;
    const a = document.createElement("a");
    a.href = `tel:${d.length===11 && d[0]==='1' ? '+'+d : (d.length===10 ? '+1'+d : d)}`; a.target = "_self";
    a.textContent = formatUSPhone(d); a.className = "cell-link"; return a;
  }

  /** ==== Image cell builder ==== */
  function buildImageCell(tdImg, row, rIdx){
    if (!imgToggle.checked) return;
    if (tdImg._imgReady) return;
    tdImg._imgReady = true;

    const cands = imgCandCache.get(rIdx) || imageCandidates(row);
    imgCandCache.set(rIdx, cands);
    if (!cands.length) return;

    const sk  = document.createElement("div"); sk.className = "skeleton";
    const img = document.createElement("img"); img.className = "thumb"; img.loading="lazy"; img.decoding="async";

    let i = 0, timeoutId = null;
    function clearTimer(){ if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; } }
    function tryNext(){
      clearTimer();
      if (i >= cands.length) { sk.remove(); tdImg.textContent = ""; doneOne(); return; }
      const raw = cands[i++]; img._rawSrc = raw;
      const src = proxify(raw); img.src = ""; img.src = src;
      timeoutId = setTimeout(()=>img.onerror && img.onerror(), IMG_TIMEOUT_MS);
    }
    img.onerror = ()=>{ clearTimer(); tryNext(); };
    img.onload  = () => {
      clearTimer();
      if ((img.naturalWidth||0) < 48 || (img.naturalHeight||0) < 48) { tryNext(); return; }
      cacheSetGoodSrc(row, img._rawSrc || ""); sk.remove(); doneOne();
    };

    const starter = ()=>{ tryNext(); }; img._startLoading = starter; lazyImgObserver.observe(img);

    const landing = preferredLandingUrl(row);
    if (landing) {
      const a = document.createElement("a");
      a.href = landing; a.target = "_blank"; a.rel = "noopener"; a.title = "Open link";
      a.appendChild(sk); a.appendChild(img); tdImg.appendChild(a);
    } else {
      tdImg.appendChild(sk); tdImg.appendChild(img);
    }
  }

  /** ==== Sort handling (header row click) ==== */
  function setSortBy(colLetter){
    if (!colLetter) { sortSpec = null; persistSort(GID, null); if (currentRows.length) render({ rows: currentRows, colCount: currentColCount }); return; }
    const idx = colLetterToIdx(colLetter);
    if (!sortSpec || sortSpec.colIdx !== idx) sortSpec = { colIdx: idx, dir: "asc" };
    else sortSpec.dir = (sortSpec.dir === "asc" ? "desc" : "asc");
    persistSort(GID, sortSpec);
    if (currentRows.length) render({ rows: currentRows, colCount: currentColCount });
  }
  function caretClassFor(colLetter){
    if (!sortSpec) return "sorted-none";
    const idx = colLetterToIdx(colLetter);
    if (sortSpec.colIdx !== idx) return "sorted-none";
    return sortSpec.dir === "asc" ? "sorted-asc" : "sorted-desc";
  }

  /** ==== Render (with per-group sort) ==== */
  function render({ rows, colCount }){
    currentRows = rows; currentColCount = colCount;

    // Compute tab average (for price band)
    let _sum = 0, _cnt = 0;
    for (let i=0; i<rows.length && i<ROW_CAP; i++){
      const r = rows[i];
      if (isOnlyColAText(r)) continue;
      const n = computePriceNumber(r[J_COL_IDX]);
      if (Number.isFinite(n)) { _sum += n; _cnt++; }
    }
    const _tabAvg = _cnt ? (_sum / _cnt) : NaN;

    imgCandCache.clear(); buildColgroup(); tbody.innerHTML = "";
    document.body.classList.toggle("hide-images", !imgToggle.checked);

    const groups = buildGroups(rows);
    const groupByHeaderIndex = new Map(groups.map(g => [g.headerIndex, g]));
    const sortedMemberLists = new Map();

    if (sortSpec && typeof sortSpec.colIdx === "number") {
      const cmp = comparator(sortSpec.colIdx, sortSpec.dir);
      for (const g of groups) {
        const sorted = [...g.members].sort(cmp);
        sortedMemberLists.set(g.headerIndex, sorted);
      }
    }

    const renderRowByIndex = (rIdx) => {
      const row = rows[rIdx];
      if (isOnlyColAText(row)) {
        const g = groupByHeaderIndex.get(rIdx);
        const tr = document.createElement("tr");
        if (rIdx === 0) tr.classList.add("is-hidden");
        if (rIdx === 1) tr.classList.add("sticky-second");
        tr.classList.add("state-header");
        if (!g.collapsed) tr.classList.add("expanded");

        const td = document.createElement("td");
        td.colSpan = 1 + (MAX_SHOW_COL_IDX + 1);
        const bar = document.createElement("div"); bar.className = "state-bar";
        const chev = document.createElement("span"); chev.className = "chev";
        const label = document.createElement("span"); label.textContent = g.stateName;
        bar.appendChild(chev); bar.appendChild(label); td.appendChild(bar); tr.appendChild(td);
        tbody.appendChild(tr);

        tr.addEventListener("click", ()=>{
          g.collapsed = !g.collapsed;
          tr.classList.toggle("expanded", !g.collapsed);
          persistGroups(groups);
          const memberRows = tbody.querySelectorAll(`tr[data-group="${g.headerIndex}"]`);
          memberRows.forEach(mtr => {
            if (g.collapsed) {
              mtr.setAttribute("data-collapsed","true");
            } else {
              mtr.removeAttribute("data-collapsed");
              const idx = parseInt(mtr.getAttribute("data-row-index"), 10);
              const row = currentRows[idx];
              const tdImg = mtr.querySelector("td.imgCol");
              if (tdImg && imgToggle.checked) buildImageCell(tdImg, row, idx);
            }
          });
        });

        const members = sortedMemberLists.has(g.headerIndex) ? sortedMemberLists.get(g.headerIndex) : g.members;
        for (const mi of members) renderDataRow(mi, g);
        return;
      }

      const belongs = groups.find(g => g.members.includes(rIdx));
      if (!belongs) renderDataRow(rIdx, null);
    };

    function renderDataRow(rIdx, groupObj){
      const row = rows[rIdx];
      const tr = document.createElement("tr");
      tr.setAttribute("data-row-index", String(rIdx));
      if (rIdx === 0) tr.classList.add("is-hidden");
      if (rIdx === 1) tr.classList.add("sticky-second");

      if (groupObj) { tr.setAttribute("data-group", groupObj.headerIndex); if (groupObj.collapsed) tr.setAttribute("data-collapsed","true"); }

      // Image cell first
      const tdImg = document.createElement("td"); tdImg.className = "imgCol";
      const groupIsCollapsed = !!(groupObj && groupObj.collapsed);
      if (imgToggle.checked && !groupIsCollapsed) { buildImageCell(tdImg, row, rIdx); }
      tr.appendChild(tdImg);

      // Data columns A..S
      for (let c = 0; c <= MAX_SHOW_COL_IDX; c++) {
        const td  = document.createElement("td");
        const txt = row[c] ?? "";
        const lower = (txt||"").toString().trim().toLowerCase();

        // Sticky header row: add clickable sorters
        if (rIdx === 1) {
          const label = (txt || "").trim();
          if (SORTABLE_HEADERS.has(label)) {
            const colLetter = SORTABLE_HEADERS.get(label);
            const span = document.createElement("span");
            span.className = `hdr-sort ${caretClassFor(colLetter)}`;
            span.title = "Click to sort within each state";
            const caret = document.createElement("span"); caret.className = "sort-caret";
            span.textContent = label + " "; span.appendChild(caret);
            span.addEventListener("click", ()=> setSortBy(colLetter));
            td.appendChild(span); tr.appendChild(td); continue;
          }
        }

        if (c === I_COL_IDX) {
          const span = document.createElement("span"); span.className = "sentiment";
          if (lower === "positive") { span.textContent = "👍"; span.title = "Positive"; }
          else if (lower === "negative") { span.textContent = "👎"; span.title = "Negative"; }
          else if (lower === "neutral")  { span.textContent = "🤷"; span.title = "Neutral";  }
          else { makeTextCell(td, txt); tr.appendChild(td); continue; }
          td.appendChild(span);
        }
        else if (c === G_COL_IDX) {
          const handleLink = buildTwitterLinkFromHandle(txt);
          if (handleLink) td.appendChild(handleLink);
          else {
            const at = extractTwitterHandleFromUrlish(txt);
            if (at) {
              const a = document.createElement("a"); a.href = `https://x.com/${at.slice(1)}`; a.target = "_blank"; a.rel = "noopener"; a.textContent = at; a.className = "cell-link";
              td.appendChild(a);
            } else {
              const frag = linkifyWithMore(txt); if (frag) td.appendChild(frag); else makeTextCell(td, txt);
            }
          }
        }
        else if (c === E_COL_IDX) {
          // Website: pretty link label (strip scheme/www, keep username tail on known platforms)
          const frag = linkifyWithMore(txt, { alwaysShow: true, pretty: true }); if (frag) td.appendChild(frag); else makeTextCell(td, txt);
        }
        else if (c === F_COL_IDX) {
          // Link tree / aggregators: pretty too
          const frag = linkifyWithMore(txt, { alwaysShow: true, pretty: true }); if (frag) td.appendChild(frag); else makeTextCell(td, txt);
        }
        else if (c === P_COL_IDX) { const rl = buildRedditLink(txt); if (rl) td.appendChild(rl); else { const frag = linkifyWithMore(txt); if (frag) td.appendChild(frag); else makeTextCell(td, txt); } }
        else if (c === Q_COL_IDX) { const tel = buildTelAnchor(txt); if (tel) td.appendChild(tel); else { const frag = linkifyWithMore(txt); if (frag) td.appendChild(frag); else makeTextCell(td, txt); } }
        else if (c === J_COL_IDX) {
          // Price: show cleaned numeric + inline band badge; sorting handled in comparator
          const n = computePriceNumber(txt);
          const cleaned = Number.isFinite(n) ? `$${Math.round(n)}` : (txt || "").replace(/(?:high|mid|low|unknown|\?)/gi,'').trim() || "Unknown";
          // Compute tab average again from closure (works because defined in render)
          let band = "—";
          // Quick recompute of avg in this scope is not needed; reuse earlier calc via closure vars
          // To access _tabAvg, we define it in outer scope of render (already done)
          // Here we re-calc diff safely:
          (function(){
            let sum=0,cnt=0;
            // No: recomputing is heavy; but for correctness in this isolated scope, we won't recompute.
          })();
          // We'll store _tabAvg on render function for reuse:
          const avg = render._tabAvg;
          if (Number.isFinite(n) && Number.isFinite(avg)) {
            const diff = n - avg;
            band = Math.abs(diff) <= 150 ? "average" : (diff > 150 ? "↑ above average" : "↓ below average");
          }
          const wrap = document.createElement("div");
          const main = document.createElement("span"); main.textContent = cleaned;
          const badge = document.createElement("span"); badge.className = "price-badge"; badge.textContent = ` ${band}`;
          wrap.appendChild(main); wrap.appendChild(badge);
          td.appendChild(wrap);
        }
        else { const frag = linkifyWithMore(txt); if (frag) td.appendChild(frag); else makeTextCell(td, txt); }

        tr.appendChild(td);
      }

      tbody.appendChild(tr);
    }

    // expose avg to cell renderer
    render._tabAvg = _tabAvg;

    // Walk rows and render
    for (let i=0; i<rows.length && i<ROW_CAP; i++){
      const row = rows[i];
      if (isOnlyColAText(row)) {
        renderRowByIndex(i);
        const g = groups.find(x => x.headerIndex === i);
        if (g && g.members.length) i = g.members[g.members.length - 1];
      } else {
        const inGroup = groups.find(g => g.members.includes(i));
        if (!inGroup) renderRowByIndex(i);
      }
    }

    // Build search index for visible data rows
    rowTextIndex.clear();
    tbody.querySelectorAll('tr[data-row-index]').forEach(tr=>{
      const idx = parseInt(tr.getAttribute('data-row-index'), 10);
      const row = currentRows[idx] || [];
      // concatenate A..S
      const txt = row.slice(0, MAX_SHOW_COL_IDX + 1).join(" ").toLowerCase();
      rowTextIndex.set(idx, txt);
    });

    // Expand/Collapse All
    expandAllBtn.onclick = () => {
      groups.forEach(g => g.collapsed = false);
      persistGroups(groups);
      tbody.querySelectorAll("tr.state-header").forEach(tr => tr.classList.add("expanded"));
      const members = tbody.querySelectorAll('tr[data-group]');
      members.forEach(mtr => {
        mtr.removeAttribute("data-collapsed");
        const idx = parseInt(mtr.getAttribute("data-row-index"), 10);
        const row = currentRows[idx];
        const tdImg = mtr.querySelector("td.imgCol");
        if (tdImg && imgToggle.checked) buildImageCell(tdImg, row, idx);
      });
    };
    collapseAllBtn.onclick = () => {
      groups.forEach(g => g.collapsed = true);
      persistGroups(groups);
      tbody.querySelectorAll("tr.state-header").forEach(tr => tr.classList.remove("expanded"));
      tbody.querySelectorAll('tr[data-group]').forEach(tr => tr.setAttribute("data-collapsed","true"));
    };

    meta.textContent = `src=gviz • gid=${GID} • rows: ${rows.length} (showing ${Math.min(rows.length, ROW_CAP)}) • cols: ${colCount} • ${new Date().toLocaleTimeString()}`;

    // Restore scroll
    restoreScrollFor(GID);
  }

  /** ==== Search (debounced, index-backed) ==== */
  function applySearch(q, fromRender=false){
    lastQuery = (q || "").trim().toLowerCase();
    const isActive = !!lastQuery;

    const headerRows = tbody.querySelectorAll("tr.state-header");
    const dataRows   = tbody.querySelectorAll('tr[data-row-index]');

    if (isActive) {
      // Expand all groups so matches are visible
      headerRows.forEach(h => h.classList.add("expanded"));
      tbody.querySelectorAll("tr[data-group]").forEach(tr => tr.removeAttribute("data-collapsed"));

      let shown = 0;
      dataRows.forEach(tr=>{
        const idx = parseInt(tr.getAttribute("data-row-index"),10);
        const hay = rowTextIndex.get(idx) || "";
        const match = hay.includes(lastQuery);
        tr.classList.toggle("search-row-hide", !match);
        if (match) shown++;
      });
      // Always show the sticky header + first meta row
      tbody.querySelectorAll("tr.is-hidden").forEach(tr => tr.classList.add("search-row-hide"));

      meta.textContent = meta.textContent.replace(/• matches: \d+/, "");
      meta.textContent += ` • matches: ${shown}`;
    } else {
      // Clear search: show everything and re-render to restore group collapse states
      tbody.querySelectorAll("tr").forEach(tr => tr.classList.remove("search-row-hide"));
      if (!fromRender && currentRows.length) render({ rows: currentRows, colCount: currentColCount });
      meta.textContent = meta.textContent.replace(/• matches: \d+/, "");
    }
  }
  const debouncedSearch = debounce(()=>applySearch(searchBox.value), 120);

  /** ==== Scroll persistence ==== */
  function saveScrollFor(gid, top){ try { localStorage.setItem(SCROLL_KEY_PREFIX + gid, String(top|0)); } catch {} }
  function loadScrollFor(gid){ try { const v = localStorage.getItem(SCROLL_KEY_PREFIX + gid); return v ? parseInt(v, 10) || 0 : 0; } catch { return 0; } }
  const debouncedSaveScroll = debounce(()=>{ saveScrollFor(GID, scrollWrap.scrollTop || 0); }, 120);

  /** ==== Load + poll ==== */
  async function load(){
    saveScrollFor(GID, scrollWrap.scrollTop || 0);
    meta.textContent = "loading…";
    try {
      const pack = await fetchRect();
      render(pack);
      if (lastQuery) applySearch(lastQuery, /*fromRender*/true);
    } catch(e){
      console.error(e);
      meta.textContent = "Error loading GViz (check sharing / range).";
    }
  }
  let timer=null;
  function startPolling(){ if (timer) clearInterval(timer); timer = setInterval(load, POLL_MS); }

  /** ==== UI ==== */
  // Tab buttons
  $$(".button-row .btn").forEach(btn=>{
    btn.addEventListener("click", async ()=>{
      saveScrollFor(GID, scrollWrap.scrollTop || 0);
      $$(".button-row .btn").forEach(b=>b.classList.remove("active"));
      btn.classList.add("active");
      GID = btn.dataset.gid;
      try { localStorage.setItem(ACTIVE_GID_KEY, GID); } catch {}
      sortSpec = loadSort(GID);
      await load();
      if (lastQuery) applySearch(lastQuery);
    });
  });

  // Search events
  searchBox.addEventListener("input", debouncedSearch);
  clearSearchBtn.addEventListener("click", ()=>{
    searchBox.value = "";
    applySearch("");
    searchBox.focus();
  });

  // Scroll save
  scrollWrap.addEventListener("scroll", debouncedSaveScroll);

  // Image toggle (no colgroup shrinking now, only hide .imgCol)
  imgToggle.addEventListener("change", ()=>{
    saveShowImages(imgToggle.checked);
    if (currentRows.length) {
      const prevTop = scrollWrap.scrollTop || 0;
      render({ rows: currentRows, colCount: currentColCount });
      scrollWrap.scrollTop = prevTop;
    }
  });

  // Reset sort
  resetSortBtn.addEventListener("click", ()=>{
    sortSpec = null; persistSort(GID, null);
    if (currentRows.length) { const prevTop = scrollWrap.scrollTop || 0; render({ rows: currentRows, colCount: currentColCount }); scrollWrap.scrollTop = prevTop; }
  });

  // Download CSV (entire current sheet slice A..S)
  downloadCsvBtn.addEventListener("click", ()=>{
    if (!currentRows || !currentRows.length){
      alert("No data loaded yet.");
      return;
    }
    const tabName = (TABS.find(t => t.gid === GID)?.name || "data").toLowerCase().replace(/\s+/g,'-');
    const rows = currentRows.map(r => r.slice(0, MAX_SHOW_COL_IDX + 1));
    downloadCSV(`ftt-${tabName}.csv`, rows);
  });

  /** ==== Restore scroll after render ==== */
  function restoreScrollFor(gid){
    const targetTop = loadScrollFor(gid);
    requestAnimationFrame(()=>requestAnimationFrame(()=>{ scrollWrap.scrollTop = targetTop; }));
  }

  /** ==== Boot ==== */
  (async function boot(){
    try {
      const stored = localStorage.getItem(ACTIVE_GID_KEY);
      if (stored && $(`.button-row .btn[data-gid="${stored}"]`)) {
        GID = stored;
        $$(".button-row .btn").forEach(b=>b.classList.toggle("active", b.dataset.gid === GID));
      }
    } catch {}
    const v = localStorage.getItem("ftt-show-images");
    const showImages = (v === null ? true : v === "true");
    imgToggle.checked = showImages;
    document.body.classList.toggle("hide-images", !showImages);

    sortSpec = loadSort(GID);

    await load();
    startPolling();
  })();
  </script>
</body>
</html>
